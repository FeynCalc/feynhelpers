(* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ *)

(* :Title: FIRE														*)

(*
	This software is covered by the GNU General Public License 3.
	Copyright (C) 2015-2016 Vladyslav Shtabovenko
*)

(* :Summary: 	Interface between FeynCalc and FIRE							*)

(* ------------------------------------------------------------------------ *)

FIREAddPropagators::usage="FIREAddPropagators is an option for FIREBurn. Normally, for loop integrals \
that don't have enough propagators to form a complete basis, FIREBurn will automatically include \
missing propagators and put them to unity after the reduction is complete. In some cases it may \
be desirable to choose the missing propagators manually. This can be done by specifying the \
propagators via AddPropagators->{prop1,prop2,...}";

FIRESilentMode::usage="FIRESilentMode is an option for FIREBurn. When set to True, all the \
Print-output of FIRE running on the parallel kernel will be suppressed. This doesn't affect messages, \
i.e. warning or error messages will be still visible.";

FIREStartFile::usage="FIREStartFile is an option for FIREBurn. It specifies, where the start file \
for FIRE (the one generated by SaveStart[]) will be saved. The default location is the \"Database\"
folder inside FeynCalc directory"

FIREConfigFiles::usage="FIREConfigFiles is an option for FIREBurn. It specifies, where the two files \
that contain all the FIRE configuration are saved. The first file contains the lists of loop momenta, \
external momenta and propagators. Normally it ends with the FIRE command SaveStart. The second file \
loads the start file that was generated previously and reduces the given loop integrals.\
The default location of both files is the \"Database\" folder inside FeynCalc directory";

FIREPath::usage="FIREPath is an option for FIREBurn. It specifies the full location of the FIRE package. \
The default value is FileNameJoin[{$UserBaseDirectory, \"Applications\", \"FIRE5\", \"FIRE5.m\"}].";

FIREUsingFermat::usage="FIREUsingFermat is an option for FIREBurn. When set to True, FIRE will \
use FERMAT by R. H. Lewis to speed up the reduction. The default value is False. Before you \
activate FERMAT, please make sure that you have read and understood its license argreement.";

FIREBurn::usage="FIREBurn[expr,{q1,q2,..},{p1,p2,..}] reduces loop integrals with loop \
momenta q1,q2,... and external momenta p1,p2,... with integration-by-parts (IBP) relations. \
The evaluation is done on a parellel kernel using A.V. Smirnov's and V.A. Smirnov's FIRE. \
FIREBurn expects that the input doesn't contain any loop integrals with linearly dependent \
propagators. Therefore, prior to starting the reduction, use ApartFF.";

FIREBurn::tens=
"Warning! Your input contains loop integrals that have either loop momenta \
with free indices or loop momenta contracted with Dirac matrices and/or Epsilon tensors. \
Those integrals will be ignored, because FIRE doesn't handle such cases. Please perform \
the tensor reduction first.";

FIREBurn::convfail=
"Error! Conversion of the integral `1` to FIRE failed. Evaluation aborted. Reason: `2`";

FIREBurn::lindep=
"Error! The input contains integrals with linearly dependent propagators. Please perform \
partial fractioning with ApartFF first. Problematic integrals are: `1`";

FIREBurn::badcomp=
"Error! You chose to complete the propagator basis by yourself, but the inclusion of the \
propagators `1` that you specified either does not do give a complete basis for `2` or produces an \
overdetermined basis.";

FIREBurn::badconfig1=
"Error! The FIRE configuration file `1` appears to be invalid. It doesn't contain the list of \
loop momenta, that must be specified as \"Internal={...};\"";

FIREBurn::badconfig2=
"Error! The FIRE configuration file `1` appears to be invalid. It doesn't contain the list of \
propagators, that must be specified as \"Propagators={...};\"";

toFIRE::usage="";

FIREMassAbbreviation::usage="";

FIREMomentumAbbreviation::usage="";

Begin["`Package`"]
End[]

Begin["`FIRE`Private`"]

fbVerbose::usage="";

$FIREPackage = "FIRE5`FIRE5`";


Options[FIREBurn] = {
	FCVerbose -> False,
	FIREAddPropagators -> Automatic,
	FIREConfigFiles -> {ToFileName[{$FeynCalcDirectory, "Database"}, "FIREp1.m"],
						ToFileName[{$FeynCalcDirectory, "Database"}, "FIREp2.m"]},
	FIREPath -> FileNameJoin[{$UserBaseDirectory, "Applications", "FIRE5", "FIRE5.m"}],
	FIRESilentMode -> True,
	FIREStartFile -> ToFileName[{$FeynCalcDirectory, "Database"}, "FIREStartFile"],
	FIREUsingFermat -> False
};

FIREBurn[expr_, qs_List/;qs=!={}, extMom_List, opts:OptionsPattern[]] :=
	Block[ {rest, loopInts, intsUnique,
			fireList,fireRes,finalRepList,res,
			multiloop=False,needApart, allFine, needCompletion,tmpList},

		If [OptionValue[FCVerbose]===False,
			fbVerbose=$VeryVerbose,
			If[MatchQ[OptionValue[FCVerbose], _Integer?Positive | 0],
				fbVerbose=OptionValue[FCVerbose]
			];
		];

		FCPrint[1,"FIREBurn: Entering with: ", expr, FCDoControl->fbVerbose];
		FCPrint[1,"FIREBurn: Loop momenta: ", qs, " ", FCDoControl->fbVerbose];
		FCPrint[1,"FIREBurn: External momenta: ", extMom, " ", FCDoControl->fbVerbose];

		(* 	If the user specifies more than one loop momentum, only multi-loop integrals
			are treated in the expression.	*)
		If[	Length[qs]>1,
			multiloop=True
		];

		{rest,loopInts,intsUnique} = FCLoopExtract[expr,qs,loopIntegral,FCLoopSplit->{2,3},MultiLoop->multiloop,PaVe->False,
			FCI->True];

		(* 	If the input contains loop integrals with loop momenta that are uncontracted,
			or contracted with Dirac matrices or epsilon tensors, issue a warning.*)
		If [  FCLoopSplit[rest,qs][[4]]=!=0,
			Message[FIREBurn::tens]
		];

		FCPrint[1,"FIREBurn: List of unique loop integrals: ", intsUnique,  FCDoControl->fbVerbose];

		(* TODO Must sort out loop integrals that do not require a reduction!!! *)


		(*	Check that the propagators of each integral form a basis	*)
		tmpList=Map[{#, FCLoopBasisIncompleteQ[#,qs,FCI->True],
			FCLoopBasisOverdeterminedQ[#,qs,FCI->True]}&,(intsUnique/.loopIntegral->Identity)];

		needApart=Cases[tmpList,{_,True|False,True}];
		allFine=Cases[tmpList,{_,False,False}];
		needCompletion=Cases[tmpList,{_,True,False}];

		If[needApart=!={},
			Message[FIREBurn::lindep,ToString[needApart,InputForm]];
			Abort[]
		];

		(* Check that we correctly decomposed the list of unique integrals*)
		If[	Sort[Join[allFine,needCompletion]]=!=Sort[tmpList],
			Print["Error..."];
			Abort[]
		];


		allFine=Map[{#[[1]],{}}&,allFine];
		needCompletion=Map[FCLoopBasisFindCompletion[#[[1]],qs]&,needCompletion];

		fireList = Map[{toFIRE[FCE[#[[1]]],qs],#[[2]]}&,Sort[Join[allFine,needCompletion]]];



		fireList= Map[Join[#[[1]],Thread[List[(FCE/@#[[2]]), 0, "DUMMY"]]]&,fireList];


		fireList = fireList /. {ii_,jj_Integer,kk_} :> {ReplaceAll[ii,SPD->Times],jj,kk};

		FCPrint[3,"FIREBurn: Fire list: ", fireList, " ", FCDoControl->fbVerbose];

		(* Process the integrals *)
		If[	fireList=!={},
			fireRes=Map[batchFIRE[qs,extMom,#,Join[FilterRules[Options[FIREBurn], Except[{opts}]], {opts}]]&, fireList],
			fireRes={}
		];

		(* Solutions list *)
		finalRepList= MapThread[Rule[#1,#2]&,{intsUnique,fireRes}];
		(* Final result *)
		res = rest + FCI[loopInts/.finalRepList];

		FCPrint[1,"FIREBurn: Leaving with: ", res, FCDoControl->fbVerbose];
		res
	];

(*	Converts the output of FIRE into FeynCalc notation	*)
fromFIRE[props_List,qs_List]:=
	Block[{pow,tmp,res,list},
		FCPrint[4,"fromFIRE: Entering with: ", props , " | ", qs, " ", FCDoControl->fbVerbose];
		tmp = Map[list@@#&,props];

		(* TODO: What if FAD appears with negative power -> need conversion*)
		(* TODO: What if scalar product appears with  positive power -> need to handle it somehow...*)
		tmp = Replace[tmp, {
			list[_, i_, j_]/;Head[j]===FAD :> Power[j,i],
			list[_, i_, j_]/;Head[j]===SPD :> Power[j,-i],
			list[_, 0, "DUMMY"] :> 1
			}, 1];
		FCPrint[4,"fromFIRE: Converted propagators: ", tmp, FCDoControl->fbVerbose];
		(*Global`XXX = tmp;
		If[!FreeQ[tmp,list],
			(*TODO some cross checks *)
			Message["..."];
			Abort[]
		];*)

		res = Times@@tmp;

		FCPrint[4,"fromFIRE: Intermediate result :", res, FCDoControl->fbVerbose];
		res = FeynAmpDenominatorCombine[res];
		FCPrint[4,"fromFIRE: Final result :", res, FCDoControl->fbVerbose];
		res
	];

(*	Converts the output of FeynCalc into FIRE notation	*)
toFIRE[int_,qs_List] :=
	Block[{one,two,res,pow,check},

		If[	!MatchQ[int,FAD[b__]/;!FreeQ2[{b},qs]] &&
			!MatchQ[int,((qps : Times[SPD[_, _]^_. ..] ) FAD[b__])/;!FreeQ2[{b,qps},qs]],
			Message[FIREBurn::convfail,ToString[int,InputForm],"toFIRE can't recognize the form of the integral."];
			Abort[]
		];
		res = Tally[ReplaceAll[List@@(one*two*FeynAmpDenominatorSplit[int,FCE->True]),one | two -> Unevaluated[Sequence[]]]];
		FCPrint[4,"toFIRE: Preparing the conversion :", res, FCDoControl->fbVerbose];
		res = res/.Power -> pow /.	{pow[x_, i1_Integer], i2_Integer} :> {x, i1*i2} //. {
									{SPD[x_, y_], i_Integer} :> {x*y,-i, SPD[x,y]}, (* scalar products count as negative propagators*)
									{FAD[mom_],i_Integer}/;Head[mom]=!=List:> {mom^2,i,FAD[mom]},
									{FAD[{mom_,mass_}],i_Integer}:> {mom^2-mass^2,i,FAD[{mom,mass}]}
									};

		FCPrint[4,"toFIRE: Intermediate result :", res, FCDoControl->fbVerbose];
		If[!MatchQ[res, {{_, _Integer, _SPD|_FAD} ..}],
			Message[FIREBurn::convfail,int,res];
			Abort[]
		];

		(* 	check that there is one-to-one correspondence between the list
			of propagators and the original integral *)
		check = fromFIRE[res,qs];
		If[((int-(check/.massHead->Identity))//FCI//FDS) =!= 0,
			Message[FIREBurn::convfail,int,ToString[(int-check)//FCI//FDS,InputForm]];
			Abort[]
		];

		res
	];

batchFIRE[qs_List,ext_List,props_List,opts:OptionsPattern[FIREBurn]]:=

	Block[{},
		prepareFIRE[qs,ext,props,opts];



	( RunFIRE[OptionValue[FIREConfigFiles],
		Join[FilterRules[Options[FIREBurn], Except[{opts}]], {opts}]])

	]
(* Generates batch files to run FIRE *)
prepareFIRE[qs_List,ext_List,props_List,OptionsPattern[FIREBurn]]:=
	Block[{	internal,external,prs,propagators,replacements,
			integral,tmp,addprops,startFile,fireConfig1,fireConfig2,
			fireConfigPath1,fireConfigPath2,firePath,listHead,spd},

		FCPrint[2,"prepareFIRE: Entering with:", qs, " | ",  ext, " | ", props, " ", FCDoControl->fbVerbose];

		addprops = OptionValue[FIREAddPropagators];
		startFile = OptionValue[FIREStartFile];
		fireConfigPath1 = OptionValue[FIREConfigFiles][[1]];
		fireConfigPath2 = OptionValue[FIREConfigFiles][[2]];
		firePath = OptionValue[FIREPath];

		(* TODO FIX THIS!!! *)
		If[	addprops=!=Automatic && Head[addprops]===List && addprops=!={},

			(* If the user wants to compete the basis by hand	*)
			prs = Join[Cases[props,{_,x_/;x=!=0}],Map[{#,0}&,addprops]];

			(* 	Check that with this completion the basis is indeed complete and not
				overdetermined	*)
			tmp=fromFIRE[prs /. {a_ b_,0}:>{a b,-1} /. {a_^2 - b_^2,0}:>{a^2-b^2,1},qs];
			FCPrint[3,"prepareFIRE: Integral with missing propagators (user input):", tmp, FCDoControl->fbVerbose];
			If[!(!FCLoopBasisIncompleteQ[tmp,qs,FCI->True] && !FCLoopBasisOverdeterminedQ[tmp,qs,FCI->True]),
				Message[FIREBurn::badcomp,ToString[addprops,InputForm],ToString[tmp,InputForm]];
				Abort[]
			],
			prs = props
		];

		(* 	We take only loop and external momenta that are explicitly present in the integral.
			Otherwise FIRE might "wrongly" set the integral to zero *)
		internal=Select[qs,!FreeQ2[{prs},#]&];
		external=Select[ext, !FreeQ2[{prs},#]&];

		(*	kinematics for external momenta	*)
		replacements=Map[Rule[#/.spd->Times, #/.spd->SPD] &,
			Union[Map[spd[#[[1]], #[[2]]] &, Union[Sort /@ Tuples[external, 2]]]]];


		(* Fish out undefined scalar products *)
		replacements = replacements/. Rule[_,_SPD]:>Unevaluated[Sequence[]];

		(*	unique propagators	*)
		propagators= prs/.{a_,_Integer,_}:>a;

		(*	this is the integral F[1,xxx] that FIRE will reduce	*)
		integral = {1,prs/.{_,a_Integer,_}:>a};

		FCPrint[3,"prepareFIRE: FIRE's Internal :", StandardForm[internal], FCDoControl->fbVerbose];
		FCPrint[3,"prepareFIRE: FIRE's External :", StandardForm[external], FCDoControl->fbVerbose];
		FCPrint[3,"prepareFIRE: FIRE's Propagators :", StandardForm[propagators], FCDoControl->fbVerbose];
		FCPrint[3,"prepareFIRE: FIRE's Replacements :", StandardForm[replacements], FCDoControl->fbVerbose];
		FCPrint[3,"prepareFIRE: FIRE's Intitial Data File :", StandardForm[startFile], FCDoControl->fbVerbose];
		FCPrint[3,"prepareFIRE: FIRE's F integral :", StandardForm[integral], FCDoControl->fbVerbose];

		fireConfig1 = OpenWrite[fireConfigPath1];
		WriteString[fireConfig1, "FIREPath=\""<> DirectoryName[firePath] <>"\";\n"];

		If	[OptionValue[FIREUsingFermat],
			WriteString[fireConfig1, "UsingFermat=True;\n"];
		];

		WriteString[fireConfig1, "Get[\""<> firePath  <>"\"];\n"];
		WriteString[fireConfig1, "Internal=" <> ToString[internal,InputForm] <> ";\n"];
		WriteString[fireConfig1, "External=" <> ToString[external,InputForm] <> ";\n"];
		WriteString[fireConfig1, StringReplace["Propagators=" <> ToString[propagators,InputForm] <> ";\n",{"SPD"->"FeynCalc`SPD","SMP"->"FeynCalc`SMP"}]];
		WriteString[fireConfig1, StringReplace["Replacements=" <> ToString[replacements,InputForm] <> ";\n",{"SPD"->"FeynCalc`SPD","SMP"->"FeynCalc`SMP"}]];
		WriteString[fireConfig1, "PrepareIBP[];\n"];
		WriteString[fireConfig1, "Prepare[AutoDetectRestrictions -> True];\n"];
		WriteString[fireConfig1, "SaveStart["<> ToString[startFile,InputForm]  <>"];\n"];
		Close[fireConfig1];

		fireConfig2 = OpenWrite[fireConfigPath2];
		WriteString[fireConfig2, "FIREPath=\""<> DirectoryName[firePath] <>"\";\n"];

		If	[OptionValue[FIREUsingFermat],
			WriteString[fireConfig2, "UsingFermat=True;\n"];
		];

		WriteString[fireConfig2, "Get[\""<> firePath  <>"\"];\n"];
		WriteString[fireConfig2, "LoadStart[" <> ToString[startFile,InputForm] <> ",1];\n"];
		WriteString[fireConfig2, "Burn[];\n"];
		WriteString[fireConfig2, StringReplace["prs="<> ToString[prs,InputForm]  <>";\n",{"SPD"->"FeynCalc`SPD","FAD"->"FeynCalc`FAD","SMP"->"FeynCalc`SMP"}]];
		WriteString[fireConfig2, "FeynCalc`FIRE`Private`feynhelpersFIREResult =  F@@" <> ToString[integral,InputForm] <> "\n"];
		WriteString[fireConfig2, "FeynCalc`FIRE`Private`feynhelpersFIREResult /. {G -> FeynCalc`FIRE`Private`feynHelpersG, d -> FeynCalc`FIRE`Private`feynHelpersDim} \n"];
		Close[fireConfig2];

	];

RunFIRE[{fireConfigPath1_,fireConfigPath2_},OptionsPattern[FIREBurn]]:=
	Block[{	tmp,propagators,qs,kernel, outFIRE, gList, pList,g,repList,
			solsList,res,null1,null2,abbreviatonsMasses={},
			abbreviatonsMomenta={},prs},


		FCPrint[3,"RunFIRE: Entering with: ", {fireConfigPath1,fireConfigPath2}, FCDoControl->fbVerbose];

		(* 	The only things we need to know to be able to convert back into FeynCalc notation are
			the loop momenta and the propagators. To support the possibility that the user supplies
			his/her own batch files and wants the output translated back into FeynCalc, the lists
			of momenta and propagators are extracted directly from the provided batch files.	*)

		(*	Get the loop momenta	*)
		tmp = FindList[fireConfigPath1, {"Internal=", "Internal =", "Internal  ="}];
		If[	Length[tmp]=!=1,
			Message[FIREBurn::badconfig1,fireConfigPath1];
			Abort[]
		];
		qs=StringTrim[tmp[[1]], {"Internal=", ";"}]//ToExpression;

		(*	Get the propagators	*)
		tmp = FindList[fireConfigPath1, {"Propagators=", "Propagators =", "Propagators  ="}];

		If[	Length[tmp]=!=1,
			Message[FIREBurn::badconfig2,fireConfigPath2];
			Abort[]
		];
		propagators=StringTrim[tmp[[1]], {"Propagators=", ";"}]//ToExpression;

		tmp = FindList[fireConfigPath2, {"prs="}];

		If[	Length[tmp]=!=1,
			Message[FIREBurn::badconfig2,fireConfigPath2];
			Abort[]
		];
		prs=StringTrim[tmp[[1]], {"prs=", ";"}]//ToExpression;


		FCPrint[3,"RunFIRE: First run", FCDoControl->fbVerbose];
		(*	First run	*)
		kernel = LaunchKernels[1];
		If[	OptionValue[FIRESilentMode],
			(* Dirty trick to prevent FIRE from flushing the front-end with its Print output  *)
			ParallelEvaluate[Unprotect[System`Print]; System`Print=System`PrintTemporary&, kernel]
		];
		With[{file1=fireConfigPath1},ParallelEvaluate[Get[file1],kernel]];
		CloseKernels[kernel];

		FCPrint[3,"RunFIRE: Second run", FCDoControl->fbVerbose];
		(*	Second run	*)
		kernel = LaunchKernels[1];
		If[	OptionValue[FIRESilentMode],
			(* Dirty trick to prevent FIRE from flushing the front-end with its Print output  *)
			ParallelEvaluate[Unprotect[System`Print]; System`Print=System`PrintTemporary&, kernel]
		];
		(* This trick with Global`G is needed b/c FeynArts also defines a G in the global context...	*)

		outFIRE = With[{file1=fireConfigPath2}

						,ParallelEvaluate[Get[file1],kernel]]/.{FeynCalc`FIRE`Private`feynHelpersG->g,FeynCalc`FIRE`Private`feynHelpersDim->System`D(*,
		ToExpression["Global`FCGV"]->fcgv*)};
		CloseKernels[kernel];

		(* LaunchKernels[1] returns an object in MMA 8 and 9, but a list element in MMA 10 and above*)
		If[	$VersionNumber>=10,
				outFIRE = Total[outFIRE];
		];

		FCPrint[3,"RunFIRE: Output of FIRE: ", outFIRE, FCDoControl->fbVerbose];

		gList = Cases[Expand2[outFIRE, g]+null1+null2, g[__] ,Infinity];
		FCPrint[3,"RunFIRE: gList: ", gList, FCDoControl->fbVerbose];

		(*	This list contains only abbreviated masses and momenta *)
		pList = Map[MapThread[{#1, #2, #3} &,
			{propagators, (# /.  g[_, i_] :> i), (prs /. {_, _, j_} /; Head[j] =!= List :>j)}] &, gList];

		FCPrint[3,"RunFIRE: pList: ", pList, FCDoControl->fbVerbose];

		solsList=fromFIRE[#,qs]&/@pList;
		repList= MapThread[Rule[#1,#2]&,{gList,solsList}];

		FCPrint[3,"RunFIRE: repList: ", repList, FCDoControl->fbVerbose];

		res = outFIRE/.repList  /.massHead-> Identity;

		FCPrint[3,"RunFIRE: Leaving with: ", res, FCDoControl->fbVerbose];
		res
	];

End[]
