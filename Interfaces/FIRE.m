(* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ *)

(* :Title: FIRE														*)

(*
	This software is covered by the GNU Lesser General Public License 3.
	Copyright (C) 2015-2016 Vladyslav Shtabovenko
*)

(* :Summary: 	Interface between FeynCalc and FIRE							*)

(* ------------------------------------------------------------------------ *)

FIREAddPropagators::usage="FIREAddPropagators is an option for FIREBurn. Normally, for loop integrals \
that don't have enough propagators to form a complete basis, FIREBurn will automatically include \
missing propagators and put them to unity after the reduction is complete. In some cases it may \
be desirable to choose the missing propagators manually. This can be done by specifying the \
propagators via AddPropagators->{prop1,prop2,...}";

FIRESilentMode::usage="FIRESilentMode is an option for FIREBurn. When set to True, all the \
Print-output of FIRE running on the parallel kernel will be suppressed. This doesn't affect messages, \
i.e. warning or error messages will be still visible.";

FIREStartFile::usage="FIREStartFile is an option for FIREBurn. It specifies, where the start file \
for FIRE (the one generated by SaveStart[]) will be saved. The default location is the \"Database\"
folder inside FeynCalc directory"

FIREConfigFiles::usage="FIREConfigFiles is an option for FIREBurn. It specifies, where the two files \
that contain all the FIRE configuration are saved. The first file contains the lists of loop momenta, \
external momenta and propagators. Normally it ends with the FIRE command SaveStart. The second file \
loads the start file that was generated previously and reduces the given loop integrals.\
The default location of both files is the \"Database\" folder inside FeynCalc directory";

FIREPath::usage="FIREPath is an option for FIREBurn. It specifies the full location of the FIRE package. \
The default value is FileNameJoin[{$UserBaseDirectory, \"Applications\", \"FIRE5\", \"FIRE5.m\"}].";

FIREUsingFermat::usage="FIREUsingFermat is an option for FIREBurn. When set to True, FIRE will \
use FERMAT by R. H. Lewis to speed up the reduction. The default value is False. Before you \
activate FERMAT, please make sure that you have read and understood its license argreement.";

FIREBurn::usage="FIREBurn[expr,{q1,q2,..},{p1,p2,..}] reduces loop integrals with loop \
momenta q1,q2,... and external momenta p1,p2,... with integration-by-parts (IBP) relations. \
The evaluation is done on a parellel kernel using A.V. Smirnov's and V.A. Smirnov's FIRE. \
FIREBurn expects that the input doesn't contain any loop integrals with linearly dependent \
propagators. Therefore, prior to starting the reduction, use ApartFF.";

FIREBurn::tens=
"Warning! Your input contains loop integrals that have either loop momenta \
with free indices or loop momenta contracted with Dirac matrices and/or Epsilon tensors. \
Those integrals will be ignored, because FIRE doesn't handle such cases. Please perform \
the tensor reduction first.";

FIREBurn::convfail=
"Error! Conversion of the integral `1` to FIRE failed. Evaluation aborted. Reason: `2`";

FIREBurn::lindep=
"Error! The input contains integrals with linearly dependent propagators. Please perform \
partial fractioning with ApartFF first. Problematic integrals are: `1`";

FIREBurn::badcomp=
"Error! You chose to complete the propagator basis by yourself, but the inclusion of the \
propagators `1` that you specified either does not do give a complete basis for `2` or produces an \
overdetermined basis.";

FIREBurn::badconfig1=
"Error! The FIRE configuration file `1` appears to be invalid. It doesn't contain the list of \
loop momenta, that must be specified as \"Internal={...};\"";

FIREBurn::badconfig2=
"Error! The FIRE configuration file `1` appears to be invalid. It doesn't contain the list of \
propagators, that must be specified as \"Propagators={...};\"";

toFIRE::usage="";

Begin["`Package`"]
End[]

Begin["`FIRE`Private`"]

fbVerbose::usage="";

$FIREPackage = "FIRE5`FIRE5`";


Options[FIREBurn] = {
	FCVerbose -> False,
	FIREAddPropagators -> Automatic,
	FIREConfigFiles -> {ToFileName[{$FeynCalcDirectory, "Database"}, "FIREp1.m"],
						ToFileName[{$FeynCalcDirectory, "Database"}, "FIREp2.m"]},
	FIREPath -> FileNameJoin[{$UserBaseDirectory, "Applications", "FIRE5", "FIRE5.m"}],
	FIRESilentMode -> True,
	FIREStartFile -> ToFileName[{$FeynCalcDirectory, "Database"}, "FIREStartFile"],
	FIREUsingFermat -> False
};

FIREBurn[expr_, qs_List/;qs=!={}, extMom_List, opts:OptionsPattern[]] :=
	Block[ {rest, loopInts, intsUnique,
			fireList,fireRes,finalRepList,res,
			multiloop=False,needApart, allFine, needCompletion,tmpList},

		If [OptionValue[FCVerbose]===False,
			fbVerbose=$VeryVerbose,
			If[MatchQ[OptionValue[FCVerbose], _Integer?Positive | 0],
				fbVerbose=OptionValue[FCVerbose]
			];
		];

		FCPrint[1,"FIREBurn: Entering with: ", expr, FCDoControl->fbVerbose];
		FCPrint[1,"FIREBurn: Loop momenta: ", qs, " ", FCDoControl->fbVerbose];
		FCPrint[1,"FIREBurn: External momenta: ", extMom, " ", FCDoControl->fbVerbose];

		(* 	If the user specifies more than one loop momentum, only multiloop integrals
			are treated in the expression.	*)
		If[	Length[qs]>1,
			multiloop=True
		];

		{rest,loopInts,intsUnique} = FCLoopExtract[expr,qs,loopIntegral,FCLoopSplit->{2,3},MultiLoop->multiloop,PaVe->False];

		(* 	If the input contains loop integrals with loop momenta that are uncontracted,
			or contracted with Dirac matrices or epsilon tensors, issue a warning.*)
		If [  FCLoopSplit[rest,qs][[4]]=!=0,
			Message[FIREBurn::tens]
		];


		(*	Check that the propagators of each integral form a basis	*)
		tmpList=Map[{#, FCLoopBasisIncompleteQ[#,qs,FCI->True],
			FCLoopBasisOverdeterminedQ[#,qs,FCI->True]}&,(intsUnique/.loopIntegral->Identity)];

		needApart=Cases[tmpList,{_,True|False,True}];
		allFine=Cases[tmpList,{_,False,False}];
		needCompletion=Cases[tmpList,{_,True,False}];

		If[needApart=!={},
			Message[FIREBurn::lindep,ToString[needApart,InputForm]];
			Abort[]
		];

		(* Check that we correctly decomposed the list of unique integrals*)
		If[	Sort[Join[allFine,needCompletion]]=!=Sort[tmpList],
			Print["Error..."];
			Abort[]
		];


		allFine=Map[{#[[1]],{}}&,allFine];
		needCompletion=Map[FCLoopBasisFindCompletion[#[[1]],qs]&,needCompletion];
		fireList = Map[{toFIRE[FCE[#[[1]]],qs],#[[2]]}&,Sort[Join[allFine,needCompletion]]];
		fireList= Map[Join[#[[1]],Thread[List[(FCE/@#[[2]]), 0]]]&,fireList]/.{SPD[a_,b_]:>a*b};

		FCPrint[3,"FIREBurn: Fire list: ", fireList, " ", FCDoControl->fbVerbose];

		(* Process the integrals *)
		If[	fireList=!={},
			fireRes=Map[batchFIRE[qs,extMom,#,Join[FilterRules[Options[FIREBurn], Except[{opts}]], {opts}]]&, fireList],
			fireRes={}
		];

		(* Solutions list *)
		finalRepList= MapThread[Rule[#1,#2]&,{intsUnique,fireRes}];
		(* Final result *)
		res = rest + FCI[loopInts/.finalRepList];

		FCPrint[1,"FIREBurn: Leaving with: ", res, FCDoControl->fbVerbose];
		res
	];

(*	Converts the output of FIRE into FeynCalc notation	*)
fromFIRE[props_List,qs_List]:=
	Block[{pow,tmp,res,head,headSP},
		res= props /. Power -> pow /. {
			{y_, int_Integer?Negative} :> headSP[(y//.
				{a_. q1_*q2_ +x_:0/;!FreeQ2[q1,qs] && !FreeQ2[q2,qs] && FreeQ[{q1,q2},SPD] :>
					a SPD[q1,q2]+ x,
				p_*q_ +x_:0/;!FreeQ2[q,qs] && FreeQ2[p,qs] && FreeQ[{q,p},SPD] :>
					SPD[q,p]+ x,
					a_. pow[q_,2]+x_:0/;!FreeQ2[q,qs]:>a*SPD[q,q]+x}),-int],
			{_, 0} :> Unevaluated[Sequence[]],
			{x_, int_Integer?Positive} :>
				(tmp=FCSplit[x,qs]; Power[FAD[{head[(tmp[[2]]/.pow[mom_, 2]:>mom)],
				head[(tmp[[1]]/.{-pow[m_, 2]:>m})]}],int])};
		FCPrint[4,"fromFIRE: Intermediate result :", res, FCDoControl->fbVerbose];
		res = FeynAmpDenominatorCombine[Times@@(res /.pow->Power /.headSP->Power /. head->Identity)];
		FCPrint[4,"fromFIRE: Final result :", res, FCDoControl->fbVerbose];
		res
	];

(*	Converts the output of FeynCalc into FIRE notation	*)
toFIRE[int_,qs_List] :=
	Block[{one,two,res,pow,check},

		If[	!MatchQ[int,FAD[b__]/;!FreeQ2[{b},qs]] &&
			!MatchQ[int,((qps : Times[SPD[_, _]^_. ..] ) FAD[b__])/;!FreeQ2[{b,qps},qs]],
			Message[FIREBurn::convfail,ToString[int,InputForm],"toFIRE can't recognize the form of the integral."];
			Abort[]
		];
		res = Tally[ReplaceAll[List@@(one*two*FeynAmpDenominatorSplit[int,FCE->True]),one | two -> Unevaluated[Sequence[]]]];

		res = res/.Power -> pow /.	{pow[x_, i1_Integer], i2_Integer} :> {x, i1*i2} //. {
									{SPD[x_, y_], i_Integer} :> {x*y,-i}, (* scalar products count as negative propagators*)
									{FAD[mom_],i_Integer}/;Head[mom]=!=List:> {mom^2,i},

									(* massHead is here to protect complicated mass terms like a*m or I*m etc. *)
									{FAD[{mom_,mass_}],i_Integer}:> {mom^2-massHead[mass]^2,i}
									};

		FCPrint[4,"toFIRE: Intermediate result :", res, FCDoControl->fbVerbose];

		If[!MatchQ[res, {{_, _Integer} ..}],
			Message[FIREBurn::convfail,int,res];
			Abort[]
		];

		(* 	check that there is one-to-one correspondence between the list
			of propagators and the original integral *)
		check = fromFIRE[res,qs];
		If[((int-(check/.massHead->Identity))//FCI//FDS) =!= 0,
			Message[FIREBurn::convfail,int,ToString[(int-check)//FCI//FDS,InputForm]];
			Abort[]
		];

		res
	];

batchFIRE[qs_List,ext_List,props_List,opts:OptionsPattern[FIREBurn]]:=

	Block[{},
		prepareFIRE[qs,ext,props,opts];



	( RunFIRE[OptionValue[FIREConfigFiles],
		Join[FilterRules[Options[FIREBurn], Except[{opts}]], {opts}]])

	]
(* Generates batch files to run FIRE *)
prepareFIRE[qs_List,ext_List,props_List,OptionsPattern[FIREBurn]]:=
	Block[{	internal,external,prs,propagators,replacements,
			integral,tmp,addprops,startFile,fireConfig1,fireConfig2,
			fireConfigPath1,fireConfigPath2,firePath,abbrListMasses={},
			abbrListMoms={}},

		addprops = OptionValue[FIREAddPropagators];
		startFile = OptionValue[FIREStartFile];
		fireConfigPath1 = OptionValue[FIREConfigFiles][[1]];
		fireConfigPath2 = OptionValue[FIREConfigFiles][[2]];
		firePath = OptionValue[FIREPath];

		If[	addprops=!=Automatic && Head[addprops]===List && addprops=!={},

			(* If the user wants to compete the basis by hand	*)
			prs = Join[Cases[props,{_,x_/;x=!=0}],Map[{#,0}&,addprops]];

			(* 	Check that with this completion the basis is indeed complete and not
				overdetermined	*)
			tmp=fromFIRE[prs /. {a_ b_,0}:>{a b,-1} /. {a_^2 - b_^2,0}:>{a^2-b^2,1},qs];
			FCPrint[3,"runFIRE: Integral with missing propagators (user input):", tmp, FCDoControl->fbVerbose];
			If[!(!FCLoopBasisIncompleteQ[tmp,qs,FCI->True] && !FCLoopBasisOverdeterminedQ[tmp,qs,FCI->True]),
				Message[FIREBurn::badcomp,ToString[addprops,InputForm],ToString[tmp,InputForm]];
				Abort[]
			],
			prs = props
		];

		(* 	We take only loop and external momenta that are explicitly present in the integral.
			Otherwise FIRE might "wrongly" set the integral to zero *)
		internal=Select[qs,!FreeQ2[{prs},#]&];
		external=Select[ext, !FreeQ2[{prs},#]&];

		(* 	The seed of unique must be lowercase! FLink might crash if the unique names become too long,
			but since we always start counting with 1, this is unlikely to happend, until the counter goes
			to some very large number.  *)
		abbrListMasses=MapIndexed[Rule[Power[#1,2], ToExpression["am"<>ToString[Identity@@#2]]] &, Union[Cases[prs,massHead[__],Infinity]]];

		abbrListMoms=MapIndexed[Rule[#1, ToExpression["ap"<>ToString[Identity@@#2]]] &,
			Union[Map[Times[#[[1]], #[[2]]] &, Union[Sort /@ Tuples[external, 2]]]]];

		(* Fish out numerical values for external momenta	*)
		abbrListMoms = Map[ If[ NumberQ[SPD[#[[1]],#[[2]]]],
						Rule[#[[1]],SPD[#[[1]],#[[2]]]],
						#]&, abbrListMoms];

		(*	kinematics for external momenta	*)
		replacements= abbrListMoms;

		(*Map[
			If[ IntegerQ[SPD[#[[1]], #[[2]]]],
				Rule[Apply[Times, #],
				SPD[#[[1]], #[[2]]]],Unevaluated[Sequence[]]] &, Union[Sort /@ Tuples[external, 2]]];*)


		prs= prs//.abbrListMasses /. abbrListMoms;


		(*TODO fix this*)
		If[!FreeQ[prs,massHead],
			Message[FIREBurn::fail,""];
			Abort[]
		];

		(*	unique propagators	*)
		propagators= prs/.{a_,_Integer}:>a;



		(*	this is the integral F[1,xxx] that FIRE will reduce	*)
		integral = {1,prs/.{_,a_Integer}:>a};

		FCPrint[3,"prepareFIRE: FIRE's Internal :", StandardForm[internal], FCDoControl->fbVerbose];
		FCPrint[3,"prepareFIRE: FIRE's External :", StandardForm[external], FCDoControl->fbVerbose];
		FCPrint[3,"prepareFIRE: FIRE's Propagators :", StandardForm[propagators], FCDoControl->fbVerbose];
		FCPrint[3,"prepareFIRE: FIRE's Replacements :", StandardForm[replacements], FCDoControl->fbVerbose];
		FCPrint[3,"prepareFIRE: FIRE's Intitial Data File :", StandardForm[startFile], FCDoControl->fbVerbose];
		FCPrint[3,"prepareFIRE: FIRE's F integral :", StandardForm[integral], FCDoControl->fbVerbose];

		fireConfig1 = OpenWrite[fireConfigPath1];
		WriteString[fireConfig1, "FIREPath=\""<> DirectoryName[firePath] <>"\";\n"];

		If	[OptionValue[FIREUsingFermat],
			WriteString[fireConfig1, "UsingFermat=True;\n"];
		];

		WriteString[fireConfig1, "Get[\""<> firePath  <>"\"];\n"];
		WriteString[fireConfig1, "Internal=" <> ToString[internal,InputForm] <> ";\n"];
		WriteString[fireConfig1, "External=" <> ToString[external,InputForm] <> ";\n"];
		WriteString[fireConfig1, "Propagators=" <> ToString[propagators,InputForm] <> ";\n"];
		WriteString[fireConfig1, "Replacements=" <> ToString[replacements,InputForm] <> ";\n"];
		WriteString[fireConfig1, "PrepareIBP[];\n"];
		WriteString[fireConfig1, "Prepare[AutoDetectRestrictions -> True];\n"];
		WriteString[fireConfig1, "SaveStart["<> ToString[startFile,InputForm]  <>"];\n"];
		Close[fireConfig1];

		fireConfig2 = OpenWrite[fireConfigPath2];
		WriteString[fireConfig2, "FIREPath=\""<> DirectoryName[firePath] <>"\";\n"];

		If	[OptionValue[FIREUsingFermat],
			WriteString[fireConfig2, "UsingFermat=True;\n"];
		];

		WriteString[fireConfig2, "Get[\""<> firePath  <>"\"];\n"];
		WriteString[fireConfig2, "LoadStart[" <> ToString[startFile,InputForm] <> ",1];\n"];
		WriteString[fireConfig2, "Burn[];\n"];
		WriteString[fireConfig2, "abbrListMasses="<> ToString[Reverse/@abbrListMasses,InputForm]  <>";\n"];
		WriteString[fireConfig2, "abbrListMoms="<> ToString[Reverse/@abbrListMoms,InputForm]  <>";\n"];
		WriteString[fireConfig2, "F@@" <> ToString[integral,InputForm] <> "\n"];
		Close[fireConfig2];

	];

RunFIRE[{fireConfigPath1_,fireConfigPath2_},OptionsPattern[FIREBurn]]:=
	Block[{	tmp,propagators,qs,kernel, outFIRE, gList, pList,g,repList,
			solsList,res,null1,null2,abbreviatonsMasses={},
			abbreviatonsMomenta={}},


		FCPrint[3,"RunFIRE: Entering with: ", {fireConfigPath1,fireConfigPath2}, FCDoControl->fbVerbose];

		(* 	The only things we need to know to be able to convert back into FeynCalc notation are
			the loop momenta and the propagators. To support the possibility that the user supplies
			his/her own batch files and wants the output translated back into FeynCalc, the lists
			of momenta and propagators are extracted directly from the provided batch files.	*)

		(*	Get the loop momenta	*)
		tmp = FindList[fireConfigPath1, {"Internal=", "Internal =", "Internal  ="}];
		If[	Length[tmp]=!=1,
			Message[FIREBurn::badconfig1,fireConfigPath1];
			Abort[]
		];
		qs=StringTrim[tmp[[1]], {"Internal=", ";"}]//ToExpression;

		(*	Get the propagators	*)
		tmp = FindList[fireConfigPath1, {"Propagators=", "Propagators =", "Propagators  ="}];

		If[	Length[tmp]=!=1,
			Message[FIREBurn::badconfig2,fireConfigPath2];
			Abort[]
		];
		propagators=StringTrim[tmp[[1]], {"Propagators=", ";"}]//ToExpression;

		(*	Get the abbreviations for masses. This one is optional.	*)
		tmp = FindList[fireConfigPath2, {"abbrListMasses="}];

		If[	Length[tmp]===1,
			abbreviatonsMasses=StringTrim[tmp[[1]], {"abbrListMasses=", ";"}]//ToExpression;
		];

		(*	Get the abbreviations for masses. This one is optional.	*)
		tmp = FindList[fireConfigPath2, {"abbrListMoms="}];

		If[	Length[tmp]===1,
			abbreviatonsMomenta=StringTrim[tmp[[1]], {"abbrListMoms=", ";"}]//ToExpression;
		];


		FCPrint[3,"RunFIRE: List of abbreviations for masses: ", abbreviatonsMasses, FCDoControl->fbVerbose];
		FCPrint[3,"RunFIRE: List of abbreviations for momenta: ", abbreviatonsMomenta, FCDoControl->fbVerbose];

		FCPrint[3,"RunFIRE: First run", FCDoControl->fbVerbose];
		(*	First run	*)
		kernel = LaunchKernels[1];
		If[	OptionValue[FIRESilentMode],
			(* Dirty trick to prevent FIRE from flushing the front-end with its Print output  *)
			ParallelEvaluate[Unprotect[System`Print]; System`Print=System`PrintTemporary&, kernel]
		];
		With[{file1=fireConfigPath1},ParallelEvaluate[Get[file1],kernel]];
		CloseKernels[kernel];

		FCPrint[3,"RunFIRE: Second run", FCDoControl->fbVerbose];
		(*	Second run	*)
		kernel = LaunchKernels[1];
		If[	OptionValue[FIRESilentMode],
			(* Dirty trick to prevent FIRE from flushing the front-end with its Print output  *)
			ParallelEvaluate[Unprotect[System`Print]; System`Print=System`PrintTemporary&, kernel]
		];
		(* This trick with Global`G is needed b/c FeynArts also defines a G in the global context...	*)
		outFIRE = With[{file1=fireConfigPath2},ParallelEvaluate[Get[file1],kernel]]/.{ToExpression["Global`G"]->g,ToExpression["Global`d"]->System`D};
		CloseKernels[kernel];

		(* LaunchKernels[1] returns an object in MMA 8 and 9, but a list element in MMA 10 and above*)
		If[	$VersionNumber>=10,
				outFIRE = Total[outFIRE];
		];

		FCPrint[3,"RunFIRE: Output of FIRE: ", outFIRE, FCDoControl->fbVerbose];

		gList = Cases[Expand2[outFIRE, g]+null1+null2, g[__] ,Infinity];
		FCPrint[3,"RunFIRE: gList: ", gList, FCDoControl->fbVerbose];

		pList = Map[MapThread[{#1, #2} &, {propagators, (#/. g[_, i_] :> i)}]&,gList];
		pList = Map[(#/. {_,0}:>Unevaluated[Sequence[]])&,pList];
		FCPrint[3,"RunFIRE: pList: ", pList, FCDoControl->fbVerbose];

		solsList=fromFIRE[#,qs]&/@pList;
		repList= MapThread[Rule[#1,#2]&,{gList,solsList}];

		FCPrint[3,"RunFIRE: repList: ", repList, FCDoControl->fbVerbose];

		res = outFIRE/.repList/. abbreviatonsMasses /.massHead->Identity /. abbreviatonsMomenta;

		FCPrint[3,"RunFIRE: Leaving with: ", res, FCDoControl->fbVerbose];
		res
	];

End[]
