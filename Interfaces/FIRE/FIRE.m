(* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ *)

(* :Title: FIRE														*)

(*
	This software is covered by the GNU General Public License 3.
	Copyright (C) 2015-2018 Vladyslav Shtabovenko
*)

(* :Summary: 	Interface between FeynCalc and FIRE							*)

(* ------------------------------------------------------------------------ *)

FIREAddPropagators::usage="FIREAddPropagators is an option for FIREBurn. Normally, for loop integrals \
that don't have enough propagators to form a complete basis, FIREBurn will automatically include \
missing propagators and put them to unity after the reduction is complete. In some cases it may \
be desirable to choose the missing propagators manually. This can be done by specifying the \
propagators via AddPropagators->{prop1,prop2,...}";

FIRESilentMode::usage="FIRESilentMode is an option for FIREBurn. When set to True, all the \
Print-output of FIRE running on the parallel kernel will be suppressed. This doesn't affect messages, \
i.e. warning or error messages will be still visible.";

FIREStartFile::usage="FIREStartFile is an option for FIREBurn. It specifies, where the start file \
for FIRE (the one generated by SaveStart[]) will be saved. The default location is the \"Database\"
folder inside FeynCalc directory"

FIREConfigFiles::usage="FIREConfigFiles is an option for FIREBurn. It specifies, where the three files \
that contain all the FIRE configuration are saved. The first file contains the lists of loop momenta, \
external momenta and propagators. Normally it ends with the FIRE command SaveStart. The second file \
loads the start file that was generated previously and reduces the given loop integrals.\
Finally, the third one contains replacements rules for the introduced abbreviations. \
The default location of these files is the \"Database\" folder inside FeynCalc directory";

FIREPath::usage="FIREPath is an option for FIREBurn. It specifies the full location of the FIRE package. \
The default value is FileNameJoin[{$UserBaseDirectory, \"Applications\", \"FIRE5\", \"FIRE5.m\"}].";

FIRERun::usage="FIRERun is an option for FIREBurn. When set to False, the interface will only create
configuration files specified in FIREConfigFiles but will not run FIRE on these files.";

FIREUsingFermat::usage="Experimental! FIREUsingFermat is an option for FIREBurn. When set to True, \
FIRE will use FERMAT by R. H. Lewis to speed up the reduction. The default value is False. Before
you activate FERMAT, please make sure that you have read and understood its license argreement.";

FIREBurn::usage="FIREBurn[expr,{q1,q2,..},{p1,p2,..}] reduces loop integrals with loop \
momenta q1,q2,... and external momenta p1,p2,... with integration-by-parts (IBP) relations. \
The evaluation is done on a parellel kernel using A.V. Smirnov's and V.A. Smirnov's FIRE. \
FIREBurn expects that the input doesn't contain any loop integrals with linearly dependent \
propagators. Therefore, prior to starting the reduction, use ApartFF.";

FIREBurn::tens=
"Warning! Your input contains loop integrals that have either loop momenta \
with free indices or loop momenta contracted with Dirac matrices and/or Epsilon tensors. \
Those integrals will be ignored, because FIRE doesn't handle such cases. Please perform \
the tensor reduction first.";

FIREBurn::convfail=
"Error! Conversion of the integral `1` to FIRE failed. Evaluation aborted. Reason: `2`";

FIREBurn::lindep=
"Error! The input contains integrals with linearly dependent propagators. Please perform \
partial fractioning with ApartFF first. Problematic integrals are: `1`";

FIREBurn::badcomp=
"Error! You chose to complete the propagator basis by yourself, but the inclusion of the \
propagators `1` that you specified either does not do give a complete basis for `2` or produces an \
overdetermined basis.";

FIREBurn::badconfig1=
"Error! The FIRE configuration file `1` appears to be invalid. It doesn't contain the list of \
loop momenta, that must be specified as \"Internal={...};\"";

FIREBurn::badconfig2=
"Error! The FIRE configuration file `1` appears to be invalid. It doesn't contain the list of \
propagators, that must be specified as \"Propagators={...};\"";

FIREBurn::failmsg =
"Error! FIREBurn has encountered a fatal problem and must abort the computation. \
The problem reads: `1`"

Begin["`Package`"]
End[]

Begin["`FIRE`Private`"]

fbVerbose::usage="";
fireSilentMode::usage="";
fireUsingFermat::usage="";
fireAddPropagators::usage="";
firePath::usage="";
fireRun::usage="";
abbreviations::usage="";

Options[FIREBurn] = {
	Collect -> True,
	FCE -> False,
	FCLoopIBPReducableQ->False,
	FCVerbose -> False,
	FIREAddPropagators -> Automatic,
	FIREConfigFiles -> {FileNameJoin[{$FeynCalcDirectory, "Database", "FIREp1.m"}],
						FileNameJoin[{$FeynCalcDirectory, "Database", "FIREp2.m"}],
						FileNameJoin[{$FeynCalcDirectory, "Database", "FIRERepList.m"}]},
	FIREPath -> FileNameJoin[{$UserBaseDirectory, "Applications", "FIRE5", "FIRE5.m"}],
	FIRERun -> True,
	FIRESilentMode -> True,
	FIREStartFile -> FileNameJoin[{$FeynCalcDirectory, "Database", "FIREStartFile"}],
	FIREUsingFermat -> False,
	Timing -> True
};

FIREBurn[expr_, qs_List/;qs=!={}, extMom_List, OptionsPattern[]] :=
	Block[ {rest, loopInts, intsUnique,
			fireList,fireRes,finalRepList,res,
			multiloop=False,needApart, allFine, needCompletion,tmpList,len,tmp,time},

		If [OptionValue[FCVerbose]===False,
			fbVerbose=$VeryVerbose,
			If[MatchQ[OptionValue[FCVerbose], _Integer],
				fbVerbose=OptionValue[FCVerbose]
			];
		];

		fireAddPropagators	= OptionValue[FIREAddPropagators];
		firePath 			= OptionValue[FIREPath];
		fireUsingFermat		= OptionValue[FIREUsingFermat];
		fireSilentMode		= OptionValue[FIRESilentMode];
		fireRun 			= OptionValue[FIRERun];

		If[	$KeepLogDivergentScalelessIntegrals,
			Message[FIREBurn::failmsg,"FIREBurn is not compatible with $KeepLogDivergentScalelessIntegrals set to True."];
			Abort[]
		];


		FCPrint[1,"FIREBurn: Entering.", FCDoControl->fbVerbose];
		FCPrint[2,"FIREBurn: Entering with: ", expr, FCDoControl->fbVerbose];
		FCPrint[2,"FIREBurn: Loop momenta: ", qs, " ", FCDoControl->fbVerbose];
		FCPrint[2,"FIREBurn: External momenta: ", extMom, " ", FCDoControl->fbVerbose];

		(* 	If the user specifies more than one loop momentum, only multi-loop integrals
			are treated in the expression.	*)
		If[	Length[qs]>1,
			multiloop=True
		];

		{rest,loopInts,intsUnique} = FCLoopExtract[expr,qs,loopIntegral,FCLoopSplit->{2,3},MultiLoop->multiloop,PaVe->False,
			FCI->True,FCLoopIBPReducableQ->OptionValue[FCLoopIBPReducableQ]];

		(* 	If the input contains loop integrals with loop momenta that are uncontracted,
			or contracted with Dirac matrices or epsilon tensors, issue a warning.*)
		If [  FCLoopSplit[rest,qs][[4]]=!=0,
			Message[FIREBurn::tens]
		];

		FCPrint[2,"FIREBurn: List of unique loop integrals: ", intsUnique,  FCDoControl->fbVerbose];

		(*	Check that the propagators of each integral form a basis	*)
		tmpList=Map[{#, FCLoopBasisIncompleteQ[#,qs,FCI->True],
			FCLoopBasisOverdeterminedQ[#,qs,FCI->True]}&,(intsUnique/.loopIntegral->Identity)];

		needApart=Cases[tmpList,{_,True|False,True}];
		allFine=Cases[tmpList,{_,False,False}];
		needCompletion=Cases[tmpList,{_,True,False}];

		If[needApart=!={},
			FCPrint[3,"FIREBurn: needApart: ", needApart, " ", FCDoControl->fbVerbose];
			Message[FIREBurn::lindep,ToString[needApart,InputForm]];
			Abort[]
		];

		(* Check that we correctly decomposed the list of unique integrals*)
		If[	Sort[Join[allFine,needCompletion]]=!=Sort[tmpList],
			Message[FIREBurn::failmsg,"The list of unique integrals was incorrectly decomposed."];
			Abort[]
		];

		allFine=Map[{#[[1]],{}}&,allFine];

		If[	fireAddPropagators=!=Automatic && Head[fireAddPropagators]===List && fireAddPropagators=!={},
			needCompletion=Map[FCLoopBasisFindCompletion[#[[1]],qs,Method->fireAddPropagators]&,needCompletion],
			needCompletion=Map[FCLoopBasisFindCompletion[#[[1]],qs]&,needCompletion]
		];

		FCPrint[3,"FIREBurn: allFine: ", allFine, " ", FCDoControl->fbVerbose];
		FCPrint[3,"FIREBurn: needCompletion: ", needCompletion, " ", FCDoControl->fbVerbose];

		fireList = Map[{toFIRE[FCE[#[[1]]],qs],#[[2]]}&,Sort[Join[allFine,needCompletion]]];
		FCPrint[3,"FIREBurn: 1st fireList: ", fireList, " ", FCDoControl->fbVerbose];

		(* TODO Should be done more elegant*)
		fireList= Map[Join[#[[1]],Thread[List[(FCE/@#[[2]]), 0, (FCE/@#[[2]])]]]&,fireList];
		FCPrint[3,"FIREBurn: 2nd fireList: ", fireList, " ", FCDoControl->fbVerbose];

		fireList = fireList /. {ii_,jj_Integer,kk_} :> {ReplaceAll[ii,SPD->Times],jj,kk};
		FCPrint[3,"FIREBurn: Final fireList: ", fireList, " ", FCDoControl->fbVerbose];

		(* Process the integrals *)
		len = Length[fireList];
		If[	fireList=!={},
			fireRes=MapIndexed[(
				FCPrint[If[OptionValue[Timing],0,1],"FIREBurn: Processing integral ", First[#2] , " of ", len, ";", UseWriteString -> True];
				time=AbsoluteTime[];
				tmp = batchFIRE[qs,extMom,#1,First[#2],
				{OptionValue[FIREConfigFiles][[1]],OptionValue[FIREConfigFiles][[2]],OptionValue[FIREConfigFiles][[3]],OptionValue[FIREStartFile]}];
				FCPrint[If[OptionValue[Timing],0,1]," IBP-reduction done, timing: ", N[AbsoluteTime[] - time, 4], "\n", UseWriteString -> True];
				tmp)&, fireList],
			fireRes={}
		];

		(* Solutions list *)
		finalRepList= MapThread[Rule[#1,#2]&,{intsUnique,fireRes}];
		FCPrint[3," Solutions list: ", finalRepList, " ", FCDoControl->fbVerbose];

		(* Final result *)
		res = rest + FCI[loopInts/.finalRepList];

		If[	OptionValue[FCE],
			res = FCE[res]
		];

		If[	OptionValue[Collect],
			res = Collect2[res, Join[{FeynAmpDenominator, FAD},qs]]
		];

		FCPrint[1,"FIREBurn: Leaving.", FCDoControl->fbVerbose];
		FCPrint[3,"FIREBurn: Leaving with: ", res, FCDoControl->fbVerbose];
		res
	];

(*	Converts the output of FIRE into FeynCalc notation	*)
fromFIRE[props_List,qs_List]:=
	Block[{pow,tmp,res,list},
		FCPrint[4,"FIREBurn: fromFIRE: Entering with: ", props , " | ", qs, " ", FCDoControl->fbVerbose];
		tmp = Map[list@@#&,props];

		tmp = Replace[tmp, {
			list[_, i_, j_]/;(MemberQ[{FAD,SFAD},Head[j]] && i>0) :> Power[j,i],
			list[_, i_, j_]/;(MemberQ[{FAD,SFAD},Head[j]] && i<0) :> Power[inversePropagator[j],-i],
			list[_, i_, j_]/;(Head[j]===SPD && i<0) :> Power[j,-i],
			(* TODO: Currently FeynCalc cannot represent HQET-type propagators 1/q.p.*)
			list[_, i_, j_]/;(Head[j]===SPD && i>0) :> Power[inverseSPD[j],i],
			list[_, 0, _] :> 1
			}, 1];
		FCPrint[4,"FIREBurn: fromFIRE: Converted propagators: ", tmp, FCDoControl->fbVerbose];

		If[!FreeQ2[tmp,{list,inversePropagator,inverseSPD}],
			FCPrint[1,"FIREBurn: fromFIRE: tmp: ", tmp, FCDoControl->fbVerbose];
			Message[FIREBurn::failmsg,"FIRE output could not be converted into valid FeynCalc input."];
			Abort[]
		];

		res = Times@@tmp;

		FCPrint[4,"FIREBurn: fromFIRE: Intermediate result: ", res, FCDoControl->fbVerbose];
		res = FeynAmpDenominatorCombine[res];
		FCPrint[4,"FIREBurn: fromFIRE: Final result: ", res, FCDoControl->fbVerbose];
		res
	];

(*	Converts the output of FeynCalc into FIRE notation	*)
toFIRE[int_,qs_List] :=
	Block[{one,two,res,pow,check,dot,aux},

		If[	!MatchQ[int,(FAD|SFAD)[b__]/;!FreeQ2[{b},qs]] &&
			!MatchQ[int,((qps : Times[SPD[_, _]^_. ..] ) (FAD|SFAD)[b__])/;!FreeQ2[{b,qps},qs]],
			FCPrint[3,"FIREBurn: toFIRE: Wrong input: ", int, FCDoControl->fbVerbose];
			Message[FIREBurn::failmsg,"toFIRE cannot recognize the form of the integral."];
			Abort[]
		];
		aux = int//FCLoopPropagatorPowersExpand//FCLoopRemoveNegativePropagatorPowers[#,FCLoopPropagatorPowersCombine->False]&;
		res = Tally[ReplaceAll[List@@(one*two*FeynAmpDenominatorSplit[aux,FCE->True]), one|two -> Unevaluated[Sequence[]]]];
		FCPrint[4,"FIREBurn: toFIRE: Preparing the conversion: ", res, FCDoControl->fbVerbose];
		res = res/. {Power -> pow, DOT->dot}/. {SFAD[x__]:> (SFAD[x] /. pow->Power)} /.	{pow[x_, i1_Integer], i2_Integer} :> {x, i1*i2};

		res = res //. {
						{SPD[x_, y_], i_Integer} :> {x*y,-i, SPD[x,y]}, (* scalar products count as negative propagators*)
						{FAD[mom_],i_Integer}/;Head[mom]=!=List:> {mom^2,i,FAD[mom]},
						{FAD[{mom_,mass_}],i_Integer}:> {mom^2-mass^2,i,FAD[{mom,mass}]},
						{SFAD[{{p0_, c_. dot[p1_, p2_]}, {m2_, 1}, 1}], i_} :> {p0^2 + c p1*p2 - m2,i, SFAD[{{p0, c DOT[p1,p2]}, {m2, 1}, 1}]},
						{SFAD[{{p0_, 0}, {m2_, 1}, 1}], i_} :> {p0^2 - m2,i, SFAD[{{p0, 0}, {m2, 1}, 1}]}
		};

		FCPrint[4,"FIREBurn: toFIRE: Intermediate result: ", res, FCDoControl->fbVerbose];
		If[!MatchQ[res, {{_, _Integer, _SPD|_FAD|_SFAD} ..}],
			Message[FIREBurn::convfail,int,res];
			Abort[]
		];

		(* 	check that there is a one-to-one correspondence between the list
			of propagators and the original integral *)
		check = fromFIRE[res,qs];
		If[((int-check)//FCLoopPropagatorPowersExpand//FDS) =!= 0,
			Message[FIREBurn::convfail,int,ToString[(int-check)//FCI//FDS,InputForm]];
			Abort[]
		];

		res
	];

batchFIRE[qs_List,ext_List,props_List,id_, {file1_String, file2_String, file3_String, startFile_String}]:=
	Block[{res,fireFile1 ,fireFile2, fireFile3, fireStartFile},

		FCPrint[3,"FIREBurn: batchFIRE: Entering with: ", qs, " | ",  ext, " | ", props, " | ", id, " ", FCDoControl->fbVerbose];
		{fireFile1, fireFile2, fireFile3, fireStartFile} = FileNameJoin[{FileNameDrop[#, -1], FileBaseName[#] <> "-int" <> ToString[id] <>
			"." <> FileExtension[#]}]&/@{file1,file2,file3,startFile};

		prepareFIRE[qs,ext,props, {fireFile1, fireFile2, fireFile3, fireStartFile}];
		If [fireRun,
			res = RunFIRE[{fireFile1,fireFile2,fireFile3}],
			res = Null
		];
		FCPrint[3,"FIREBurn: batchFIRE: Leaving with: ", res, FCDoControl->fbVerbose];
		res
	];




(* Generates batch files to run FIRE *)
prepareFIRE[qs_List,ext_List,props_List, {fireFile1_String,fireFile2_String, fireFile3_String, fireStartFile_String}]:=
	Block[{	internal,external,prs,propagators,replacements,
			integral,tmp,fireConfig, listHead,spd,spHead, sps},

		FCPrint[2,"FIREBurn: prepareFIRE: Entering with: ", qs, " | ",  ext, " | ", props, " ", FCDoControl->fbVerbose];

		prs = props;
		(* 	We take only loop and external momenta that are explicitly present in the integral.
			Otherwise FIRE might "wrongly" set the integral to zero *)
		internal=Select[qs,!FreeQ2[{prs},#]&];
		external=Select[ext, !FreeQ2[{prs},#]&];

		(*	unique propagators	*)
		propagators= prs/.{a_,_Integer,_}:>a;

		sps = Flatten[Outer[spd, ext, ext]] // Sort // DeleteDuplicates // ReplaceAll[#, spd -> SPD]&;
		sps = Select[sps,(Head[#]=!=SPD)&];


		abbreviations = FCAbbreviate[Join[propagators,sps],internal,external,Head->spHead];

		FCPrint[3,"FIREBurn: prepareFIRE: abbreviations: ", abbreviations, FCDoControl->fbVerbose];

		replacements = abbreviations[[1]]/.spHead->Times;

		propagators = propagators/.Flatten[abbreviations];
		prs = prs/.Flatten[abbreviations];

		(*	this is the integral F[1,xxx] that FIRE will reduce	*)
		integral = {1,prs/.{_,a_Integer,_}:>a};

		FCPrint[3,"FIREBurn: prepareFIRE: FIRE's Internal: ", StandardForm[internal], FCDoControl->fbVerbose];
		FCPrint[3,"FIREBurn: prepareFIRE: FIRE's External: ", StandardForm[external], FCDoControl->fbVerbose];
		FCPrint[3,"FIREBurn: prepareFIRE: FIRE's Propagators: ", StandardForm[propagators], FCDoControl->fbVerbose];
		FCPrint[3,"FIREBurn: prepareFIRE: FIRE's Replacements: ", StandardForm[replacements], FCDoControl->fbVerbose];
		FCPrint[3,"FIREBurn: prepareFIRE: FIRE's Intitial Data File: ", StandardForm[fireStartFile], FCDoControl->fbVerbose];
		FCPrint[3,"FIREBurn: prepareFIRE: FIRE's F integral: ", StandardForm[integral], FCDoControl->fbVerbose];

		fireConfig = OpenWrite[fireFile1];
		WriteString[fireConfig, "FIREPath="<> ToString[DirectoryName[firePath],InputForm] <>";\n"];

		If[	fireUsingFermat,
			WriteString[fireConfig, "UsingFermat=True;\n"];
		];
		WriteString[fireConfig, "(* Generated on "<> DateString[] <>" *)\n"];
		WriteString[fireConfig, "Get["<> ToString[firePath,InputForm]  <>"];\n"];
		WriteString[fireConfig, "Internal=" <> ToString[internal,InputForm] <> ";\n"];
		WriteString[fireConfig, "External=" <> ToString[external,InputForm] <> ";\n"];
		WriteString[fireConfig, "Propagators=" <> ToString[propagators,InputForm] <> ";\n"];
		WriteString[fireConfig, "Replacements=" <> ToString[replacements,InputForm] <> ";\n"];
		WriteString[fireConfig, "PrepareIBP[];\n"];
		WriteString[fireConfig, "Prepare[AutoDetectRestrictions -> True];\n"];
		WriteString[fireConfig, "SaveStart["<> ToString[fireStartFile,InputForm]  <>"];\n"];
		Close[fireConfig];

		fireConfig = OpenWrite[fireFile2];
		WriteString[fireConfig, "FIREPath="<> ToString[DirectoryName[firePath],InputForm] <>";\n"];

		If[	fireUsingFermat,
			WriteString[fireConfig, "UsingFermat=True;\n"];
		];

		WriteString[fireConfig, "(* Generated on "<> DateString[] <>" *)\n"];
		WriteString[fireConfig, "Get["<> ToString[firePath,InputForm]  <>"];\n"];
		WriteString[fireConfig, "LoadStart[" <> ToString[fireStartFile,InputForm] <> ",1];\n"];
		WriteString[fireConfig, "Burn[];\n"];
		WriteString[fireConfig, "FeynCalc`FIRE`Private`feynhelpersFIREResult =  F@@" <> ToString[integral,InputForm] <> "\n"];
		WriteString[fireConfig, "FeynCalc`FIRE`Private`feynhelpersFIREResult /. {G -> FeynCalc`FIRE`Private`feynHelpersG, d -> FeynCalc`FIRE`Private`feynHelpersDim} \n"];
		Close[fireConfig];

		fireConfig = OpenWrite[fireFile3];
		WriteString[fireConfig, "(* Generated on "<> DateString[] <>" *)\n"];
		WriteString[fireConfig, "prs="<> ToString[prs,InputForm]  <>";\n"];
		WriteString[fireConfig, "abbreviations="<> ToString[(Reverse/@Flatten[(abbreviations/.spHead->SPD)]),InputForm]  <>";\n"];
		Close[fireConfig];

	];

RunFIRE[{fireFile1_String, fireFile2_String, fireFile3_String}]:=
	Block[{	tmp,propagators,qs,kernel, outFIRE, gList, pList,g,repList,
			solsList,res,null1,null2,prs,abbrs},


		FCPrint[2,"RunFIRE: Entering with: ", {fireFile1,fireFile2}, FCDoControl->fbVerbose];

		(* 	The only things we need to know to be able to convert back into FeynCalc notation are
			the loop momenta and the propagators. To support the possibility that the user supplies
			his/her own batch files and wants the output translated back into FeynCalc, the lists
			of momenta and propagators are extracted directly from the provided batch files.	*)

		(*	Get the loop momenta	*)
		tmp = FindList[fireFile1, {"Internal=", "Internal =", "Internal  ="}];
		If[	Length[tmp]=!=1,
			Message[FIREBurn::badconfig1,fireFile1];
			Abort[]
		];
		qs=StringTrim[tmp[[1]], {"Internal=", ";"}]//ToExpression;

		(*	Get the propagators	*)
		tmp = FindList[fireFile1, {"Propagators=", "Propagators =", "Propagators  ="}];

		If[	Length[tmp]=!=1,
			Message[FIREBurn::badconfig2,fireFile2];
			Abort[]
		];
		propagators=StringTrim[tmp[[1]], {"Propagators=", ";"}]//ToExpression;

		FCPrint[3,"FIREBurn: RunFIRE: First run", FCDoControl->fbVerbose];
		(*	First run	*)
		kernel = LaunchKernels[1];
		If[	fireSilentMode,
			(* Dirty trick to prevent FIRE from flushing the front-end with its Print output  *)
			ParallelEvaluate[Unprotect[System`Print]; System`Print=System`PrintTemporary&, kernel]
		];
		With[{file1=fireFile1},ParallelEvaluate[Get[file1],kernel]];
		CloseKernels[kernel];

		FCPrint[3,"FIREBurn: RunFIRE: Second run", FCDoControl->fbVerbose];
		(*	Second run	*)
		kernel = LaunchKernels[1];
		If[	fireSilentMode,
			(* Dirty trick to prevent FIRE from flushing the front-end with its Print output  *)
			ParallelEvaluate[Unprotect[System`Print]; System`Print=System`PrintTemporary&, kernel]
		];

		(* This trick with Global`G is needed b/c FeynArts also defines a G in the global context...	*)
		outFIRE = With[{file1=fireFile2},
			ParallelEvaluate[Get[file1],kernel]]/.{FeynCalc`FIRE`Private`feynHelpersG->g,FeynCalc`FIRE`Private`feynHelpersDim->System`D};
		CloseKernels[kernel];

		(* LaunchKernels[1] returns an object in MMA 8 and 9, but a list element in MMA 10 and above*)
		If[	$VersionNumber>=10,
				outFIRE = Total[outFIRE];
		];

		FCPrint[3,"FIREBurn: RunFIRE: Output of FIRE: ", outFIRE, FCDoControl->fbVerbose];

		gList = Cases[Expand2[outFIRE, g]+null1+null2, g[__] ,Infinity];
		FCPrint[3,"FIREBurn: RunFIRE: gList: ", gList, FCDoControl->fbVerbose];

		tmp = FindList[fireFile3, {"prs="}];
		If[	Length[tmp]=!=1,
			Message[FIREBurn::badconfig2,fireFile2];
			Abort[]
		];
		prs=StringTrim[tmp[[1]], {"prs=", ";"}]//ToExpression;

		tmp = FindList[fireFile3, {"abbreviations="}];
		If[	Length[tmp]=!=1,
			Message[FIREBurn::badconfig2,fireFile2];
			Abort[]
		];
		abbrs=StringTrim[tmp[[1]], {"abbreviations=", ";"}]//ToExpression;

		(*	This list contains only abbreviated masses and momenta *)
		pList = Map[MapThread[{#1, #2, #3} &,
			{propagators, (# /.  g[_, i_] :> i), (prs /. {_, _, j_} /; Head[j] =!= List :>j)}] &, gList];

		FCPrint[3,"FIREBurn: RunFIRE: pList: ", pList, FCDoControl->fbVerbose];

		solsList=fromFIRE[#,qs]&/@pList;
		repList= MapThread[Rule[#1,#2]&,{gList,solsList}];

		FCPrint[3,"FIREBurn: RunFIRE: repList: ", repList, FCDoControl->fbVerbose];
		FCPrint[3,"FIREBurn: RunFIRE: abbrs: ", abbrs, FCDoControl->fbVerbose];

		res = outFIRE/.repList //. Dispatch[abbrs];

		If[	!FreeQ2[res,Variables[Last/@Flatten[abbreviations]]],
			Message[FIREBurn::failmsg,"Failed to eliminate all abbreviations from the final result."];
			Abort[]

		];



		FCPrint[3,"FIREBurn: RunFIRE: Leaving with: ", res, FCDoControl->fbVerbose];

		res
	];

inversePropagator[SFAD[a__]]:=
	1/PropagatorDenominatorExplicit[SFAD[a],FCE->True];

inversePropagator[FAD[a_ /; Head[a] =!= List]]:=
	SPD[a];

inversePropagator[FAD[a_List]] :=
	SPD[a[[1]]] - a[[2]]^2;

inverseSPD[SPD[a_,a_]]:=
	FAD[a];

inverseSPD[SPD[a_,b_]]:=
	SFAD[{{0, a.b}, {0, 1}, 1}]/; b=!=a;

End[]
